---
title: Test
tags: hw test_flag
key: 2021-03-08
author: tlt18
modify_date: 2021-03-28
---

# 第四周作业

<!--more-->

## 1 直方图均衡化

### 1.1 步骤

1. 图像中具有每种灰度级的像素的个数，形成图像的灰度统计直方图；
2. 计算累计直方图；
3. 将原图像的每个像素点的灰度值通过累计直方图映射成新的灰度级。

### 1.2 图像、直方图对比效果

![1](https://github.com/tlt18/tlt18.github.io/raw/master/fig/test/1.png)

![2](https://github.com/tlt18/tlt18.github.io/raw/master/fig/test/2.png)

![3](https://github.com/tlt18/tlt18.github.io/raw/master/fig/test/3.png)



### 1.3 分析


1. 原图像整体偏亮，在直方图中反映的是灰度分量主要集中在较高的灰度值上；
2. 均衡化后图像相比于原图更暗，但整体上各有明暗的部分从直方图中反映的是图像灰度分布更加均匀，黑白对比更加明显；
3. 从灰度映射关系上来看，均衡化过程中，像的灰度值始终低于原像，因此整体灰度值减小，图像变暗。

### 1.4 均匀化解释

虽然作业中均衡化后灰度分布确实更加均匀，也可以从理论上解释，在连续形式下，直方图均衡化后灰度分布更加均匀的原因。

假设$p_s(s)$和$p_r(r)$分别为分别表示随机变量s,t的概率密度函数，应有如下关系：

$$
p_{t}(t)=p_{s}(s) \mid\frac{d s}{d t} \mid
$$

我们在构造映射关系时使用了累计直方图，相当于：

$$
t=E_H(s)=(L-1) \int_{0}^{s} p_{s}(w) \mathrm{d} w
$$

因此

$$
\begin{aligned}
\frac{\mathrm{d} t}{\mathrm{~d} s} &=\frac{\mathrm{d} E_H(s)}{\mathrm{d} s} \\
&=(L-1) \frac{\mathrm{d}}{\mathrm{d} s} \int_{0}^{s} p_{s}(w) \mathrm{d} w=(L-1) p_{s}(s)
\end{aligned}
$$

最后得到t的概率密度函数

$$
\begin{aligned}
p_{t}(t) &=p_{s}(s)\left|\frac{\mathrm{d} s}{\mathrm{~d} t}\right| \\
&=p_{s}(s) \frac{1}{(L-1) p_{s}(s)}=\frac{1}{L-1}
\end{aligned}
$$

说明变换后灰度分布t是均匀的。当然上述证明在连续形式下成立，在离散形式下只能说灰度分布趋向于均匀化。

### 1.5 处理代码

```python
import numpy as np
import cv2
from matplotlib import pyplot as plt
img_raw = cv2.imread("./fig/work1.png")
row_size = img_raw.shape[0] # 行 264
col_size = img_raw.shape[1] # 列 329

ps = [0]*256
for r in range(row_size):
    for c in range(col_size):
        ps[img_raw[r][c][0]] += 1
ps = [x/(row_size*col_size) for x in ps]

ts = [0]*256
for i in range(256):
        ts[i] = sum(ps[0:i+1])

img_processed = np.zeros((row_size,col_size),dtype=np.uint8)

for r in range(row_size):
    for c in range(col_size):
        img_processed[r][c] = (int)(ts[img_raw[r][c][0]]*255)

ps_processed = [0]*256
for r in range(row_size):
    for c in range(col_size):
        ps_processed[img_processed[r][c]] += 1
ps_processed = [x/(row_size*col_size) for x in ps_processed]

ts=[x*255 for x in ts]
plt.plot(range(256),range(256))
plt.plot(range(256),ts)
plt.legend(['Identity Mapping','Enhance Function'])
plt.title('Enhance Function')

cv2.imshow("img_raw", img_raw)
cv2.imshow("img_processed", img_processed)

plt.figure()
plt.bar(range(0,256),ps)
plt.bar(range(0,256),ps_processed)
plt.legend(['Original Image','Processed Image'])
plt.title('Histogram for Image')

plt.show()
cv2.waitKey(0)
```



## 2 对数变换

### 2.1 步骤

1. 将每一个像素的频谱图作用函数$t=log(s+1)$，取每个像素的幅值；
2. 将变换前后的幅值归一到[0,255]区间。

### 2.2 变换前后效果对比

![4](https://github.com/tlt18/tlt18.github.io/raw/master/fig/test/4.png)

![5](https://github.com/tlt18/tlt18.github.io/raw/master/fig/test/5.png)


### 2.3 分析

1. 由于原频谱图幅值范围是0~2.2×10^5，最高值相比于其他值差别过大，归一化后整张图基本是全黑；
2. 对数变换后出现白色横竖条纹。由对数变换可知变换后低频分量大幅放大，高频分量增幅较小，因此能在变换后的图像中观察到更多细节。

### 2.4 代码

```python
import numpy as np
import cv2
from matplotlib import pyplot as plt
from scipy.io import loadmat

#读取
a = np.array([1,2,3])
filename = 'F:/img.mat'
data_raw = loadmat("./fig/work2.mat")
image_raw = data_raw['image']

amplitude_origin=  np.sqrt(image_raw.real*image_raw.real+image_raw.imag*image_raw.imag)
amplitude_origin = (amplitude_origin-np.min(amplitude_origin))/(np.max(amplitude_origin)-np.min(amplitude_origin))*255

image_processed = np.log(image_raw+1)
amplitude_processed =  np.sqrt(image_processed.real*image_processed.real+image_processed.imag*image_processed.imag)
amplitude_processed = (amplitude_processed-np.min(amplitude_processed))/(np.max(amplitude_processed)-np.min(amplitude_processed))*255
amplitude_origin=amplitude_origin.astype(np.uint8)
amplitude_processed=amplitude_processed.astype(np.uint8)

cv2.imshow("amplitude_origin", amplitude_origin)
cv2.imshow("amplitude_processed", amplitude_processed)

plt.plot(range(256),range(256))
plt.plot(range(256),255/np.log(256)*np.log(range(1,257)))
plt.legend(['Identity Mapping','Logarithmic Mapping'])
plt.title('Enhance Function')
plt.show()

cv2.waitKey(0) 
```



## 3 参考资料

[直方图均衡化](https://blog.csdn.net/schwein_van/article/details/84336633)